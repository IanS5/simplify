<?xml version='1.0' encoding='utf-8'?>
<typedef id="expression_t" name="expression_t" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief> A parsed mathmatical expression.</brief>
  <doc>An expression is a union of five structures:

- number

- prefix

- variable

- operator

- function

Which one of these structures is currently in use is stored in the `type` option.
The EXPRESSION_IS_XXX macros can be used to conveniently check the type of an expression.
See the _Expression Structures_ category for more information on each structure.
</doc>
  <type name="expression" ref="index#expression" />
  <function id="expression_add" name="expression_add">
    <brief> Add two expressions</brief>
    <doc>The specific operation this function performs differs depending on the expressions.
If lexpr is `1` and rexpr is `2` than result will be the expression `3`.
However if both expressions are the same variiable (e.g. `x`) than result will equal `2x`.
Result will _always be equivelent to lexpr `+` rexpr, and it will try to make it a scalar value,
but if that's not possible result may end up being an operator expression.
After the operation is performed both _lexpr_ and _rexpr_ are both valid.
Result may be either to _lexpr_ or _rexpr_, in that case it will replace any data the _lexpr_ or _rexpr
points to.

</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_add::result" name="result">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_add::lexpr" name="lexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_add::rexpr" name="rexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_clean" name="expression_clean">
    <brief> free all memory referenced by expression recursively, but not expression itself.</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_clean::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_collapse_left" name="expression_collapse_left">
    <brief> free the left branch of an expression, make the expressions equal to it's right branch</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_collapse_left::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_collapse_right" name="expression_collapse_right">
    <brief> free the right branch of an expression, make the expressions equal to it's left branch</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_collapse_right::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_compare" name="expression_compare">
    <brief> Compare two expressions</brief>
    <return>
      <doc>returns a comparison result</doc>
      <type name="compare_result_t" ref="index#compare_result_t" />
    </return>
    <argument id="expression_compare::expr1" name="expr1">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_compare::expr2" name="expr2">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_compare_structure" name="expression_compare_structure">
    <brief> Compare the structure of two expressions (i.e. perform expression_compare, but don't check the numbers)</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="expression_compare_structure::expr1" name="expr1">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_compare_structure::expr2" name="expr2">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_copy" name="expression_copy">
    <brief> deep copy an expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_copy::src" name="src">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_copy::dest" name="dest">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_do_logarithm" name="expression_do_logarithm">
    <brief> find the value of x in the expression `b^x = y`</brief>
    <return>
      <type name="error_t" ref="error_t#error_t" />
    </return>
    <argument id="expression_do_logarithm::b" name="b">
      <doc>@y</doc>
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_do_logarithm::y" name="y">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_do_logarithm::out" name="out">
      <doc>out will be filled with the value of `x`, or NULL if an error is returned</doc>
      <type name="expression_t" qualifier="**" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_evaluate" name="expression_evaluate">
    <brief> evaluate an expression as much as possible</brief>
    <return>
      <doc>returns an error</doc>
      <type name="error_t" ref="error_t#error_t" />
    </return>
    <argument id="expression_evaluate::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_evaluate::scope" name="scope">
      <type name="scope_t" qualifier="*" ref="scope_t#scope_t" />
    </argument>
  </function>
  <function id="expression_evaluate_comparisons" name="expression_evaluate_comparisons">
    <return>
      <type name="expression_result_t" ref="index#expression_result_t" />
    </return>
    <argument id="expression_evaluate_comparisons::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_find_variable" name="expression_find_variable">
    <brief> get the name of the first variable that appears in an expression</brief>
    <return>
      <doc>returns the variable's name, or NULL if it was not found</doc>
      <type name="variable_t" ref="variable_t#variable_t" />
    </return>
    <argument id="expression_find_variable::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_free" name="expression_free">
    <brief> free all memory referenced by the expression and the expression.</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_free::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_has_variable_or_function" name="expression_has_variable_or_function">
    <brief> check for a variable or function in the expression</brief>
    <return>
      <type builtin="yes" name="int" />
    </return>
    <argument id="expression_has_variable_or_function::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_has_variable_or_function::var" name="var">
      <type name="variable_t" ref="variable_t#variable_t" />
    </argument>
  </function>
  <function id="expression_init_function" name="expression_init_function">
    <brief> initialize a function expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_function::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_function::name" name="name">
      <type builtin="yes" name="char" qualifier="*" />
    </argument>
    <argument id="expression_init_function::length" name="length">
      <type name="size_t" />
    </argument>
    <argument id="expression_init_function::arguments" name="arguments">
      <type name="expression_list_t" qualifier="*" ref="expression_list_t#expression_list_t" />
    </argument>
  </function>
  <function id="expression_init_number" name="expression_init_number">
    <brief> initialize a new number expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_number::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_number::number" name="number">
      <type name="mpc_ptr" />
    </argument>
  </function>
  <function id="expression_init_number_d" name="expression_init_number_d">
    <brief> initialize a new number expression with a double</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_number_d::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_number_d::number" name="number">
      <type builtin="yes" name="double" />
    </argument>
  </function>
  <function id="expression_init_number_si" name="expression_init_number_si">
    <brief> initialize a new number expression with an integer</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_number_si::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_number_si::number" name="number">
      <type builtin="yes" name="long" />
    </argument>
  </function>
  <function id="expression_init_operator" name="expression_init_operator">
    <brief> initialize an operator expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_operator::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_operator::left" name="left">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_operator::operator" name="operator">
      <type name="operator_t" ref="operator_t#operator_t" />
    </argument>
    <argument id="expression_init_operator::right" name="right">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_init_prefix" name="expression_init_prefix">
    <brief> initialize a prefix expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_prefix::expression" name="expression">
      <doc>the expression to initialize</doc>
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_prefix::operator" name="operator">
      <doc>the prefix operator in the expression</doc>
      <type name="operator_t" ref="operator_t#operator_t" />
    </argument>
    <argument id="expression_init_prefix::right" name="right">
      <doc>the expression to the right of the prefix</doc>
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_init_variable" name="expression_init_variable">
    <brief> initialize a variable expression</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_init_variable::expression" name="expression">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_init_variable::name" name="name">
      <type builtin="yes" name="char" qualifier="*" />
    </argument>
    <argument id="expression_init_variable::length" name="length">
      <type name="size_t" />
    </argument>
  </function>
  <function id="expression_is_comparison" name="expression_is_comparison">
    <brief> check if the expression is an operator expression that compares it's left &amp; right branches.</brief>
    <return>
      <type builtin="yes" name="int" />
    </return>
    <argument id="expression_is_comparison::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_isolate_variable" name="expression_isolate_variable">
    <brief> isolate a variable on one side of an comparison operator.</brief>
    <doc>If no comparison operator is present, append `= 0`

</doc>
    <return>
      <doc>returns an error code</doc>
      <type name="error_t" ref="error_t#error_t" />
    </return>
    <argument id="expression_isolate_variable::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_isolate_variable::var" name="var">
      <type name="variable_t" ref="variable_t#variable_t" />
    </argument>
  </function>
  <function id="expression_multiply" name="expression_multiply">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_multiply::result" name="result">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_multiply::lexpr" name="lexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_multiply::rexpr" name="rexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_new_operator" name="expression_new_operator">
    <return>
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </return>
    <argument id="expression_new_operator::left" name="left">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_new_operator::op" name="op">
      <type name="operator_t" ref="operator_t#operator_t" />
    </argument>
    <argument id="expression_new_operator::right" name="right">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_simplify" name="expression_simplify">
    <brief> try to make `expr` as short as possible by combining child expressions</brief>
    <return>
      <doc>returns an error code</doc>
      <type name="error_t" ref="error_t#error_t" />
    </return>
    <argument id="expression_simplify::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_subtract" name="expression_subtract">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_subtract::result" name="result">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_subtract::lexpr" name="lexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
    <argument id="expression_subtract::rexpr" name="rexpr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
  <function id="expression_swap" name="expression_swap">
    <brief> swap an operator expression's left and right branch</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="expression_swap::expr" name="expr">
      <type name="expression_t" qualifier="*" ref="expression_t#expression_t" />
    </argument>
  </function>
</typedef>
